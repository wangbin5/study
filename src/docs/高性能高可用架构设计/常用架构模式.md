### 1、 高性能数据库集群
- 读写分离
    - 基本实现：主从集群
        - 一主一从、一主多从
        - 主机负责读写操作，从机负责读操作
        - 主机通过复制将数据同步到从机，每台数据库服务器都拥有全量数据
        - 业务将写操作发送到主机，读操作发送到从机
    - 引入的复杂性
        - 主从复制延迟
            - 写操作后的读操作发送给数据库主机,缺点： 业务侵入性强            
            - 读从机失败后，再读一次主机，缺点：二次读取多，主机压力大
            - 关键业务读写操作全部指向主机，非关键业务读写分离。缺点：业务要分优先级，额外工作多            
        - 分配机制: 将读写操作区分开，访问不同数据库的机制 
            - 程序代码封装：
                - 优点：实现简单，可以做较多定制化功能
                - 缺点：每种语言都要实现一次；主从切换时，需要修改程序配置，可能要重启
                - sample ：TDDL
            - 中间件封装：
                - 优点：支持多种语言；可以自动探测主从状态
                - 缺点：中间件需要支持完整的sql语法，稳定期长；中间件只转发请求，对性能要求高
                - 复杂度比程序代码封装高出一个数量级
                - sample：Mysql Proxy，Mysql Router ， Atlas    
                           
- 分库分表
    - 海量（千万、亿条）数据带来的问题
        - 数据量太大，读写性能会下降，索引性能也会下降；
        - 新建索引、修改表结构耗时过长
        - 数据备份和恢复时间过长
        - 丢失数据风险高
    - 分库分表的目的：控制单表、单库数据量的大小
    - 分库分表：
        - 将数据表按照业务拆分到多个数据库
            - 多表join的问题
            - 事务问题
            - 成本问题
        - 垂直分表
            - 将表中字段按照使用频率拆分成多张表
            - 目标是将不常使用且长度较长的字段拆分出去，比如：用户表中的描述
        - 水平分表
            - 将同样类型的数据拆分到多张表，需要通过路由算法，确定数据要映射到哪张表 
            - 常见路由算法： 
                - 范围路由， 优点:  可以平滑的扩充新表，缺点：数据分布不均匀
                - Hash路由， 优点： 数据分布均匀， 缺点： 扩充新表很麻烦
                - 配置路由， 缺点： 必须多查询一次，路由表数据量可能非常大，查询速度慢
            - join问题处理：业务代码或中间件中进行多次join，然后合并结果
            - 非路由key 查询操作：要在全部表中执行查询，然后合并结果   
    - 初创企业不建议分库分表
        - 业务不确定性强，用户量不够大，数据库性能提升不是系统的主要矛盾；如何快速实现业务才是优先级最高的活动。
        - 分库分表后，开发难度加大（不能使用夺标join操作，要考虑分布式事务），会拖慢开发进度
        
### 2、 高性能NoSql
- K-V 存储（Redis）： 解决关系数据库无法存储数据机构的问题     
- 文档数据库（MongoDB）： 
    - 解决关系数据库schema限定的问题
    - 优点：
        - 增加字段很容易
        - 历史数据不会出错
        - 可以存储复杂结构数据
    - 缺点：
        - 不能实现关系数据库的join
- 列式数据库（Hive）
    - 优点
        - 压缩比较高，在8:1 到30:1之间
        - 只读取1列，读取性能高，适合离线大数据分析和统计场景
- 全文搜索引擎
    - 支持模糊匹配
    - 支持复杂的查询条件

### 3、 高性能缓存架构
- 适合场景
    - 复杂运算后得出的数据
    - 读多写少的数据
- 带来的复杂性
    - 缓存穿透： 
        1. 数据不存在：如果数据不存在，将一个默认值放到缓存中。
        2. 缓存数据生成耗费大量资源，如： 爬虫使用商品分页查询，处理办法： 并且第xx页之后的请求，不放入缓存。        
    - 缓存雪崩：缓存失效后，多个线程同时请求数据导致存储系统压力过大
        1. 更新锁机制：缓存更新操作加锁（可能需要分布式锁）保护，一次只有一个线程进行缓存更新。
        2. 后台更新：  缓存有效期设为永久，后台线程去更新缓存
            - 内存不足，删除缓存数据带来问题的解决方案
                - 被动方式： 后台线程定时读取缓存，如果失效，就重新设置缓存。定时时长设定存在问题
                - 主动方式： 业务线程发现缓存失效后，发送消息通知后台线程更新缓存。依赖消息队列，复杂性较高但是用户体验好
            - 还是和业务刚上线时的缓存预热
    - 热门数据做多副本缓存，客户端轮流使用副本
        - 缓存key里增加编号信息
        - 不要统一设置多个副本的到期时间，最好是预计到期时间+随机数

### 4、 单服务器高性能模式
- PPC & TPC
    - 每个链接一个进程（线程）
    - 实现简单，但是无法支持高并发        
- Reactor 模式
    - 同步非阻塞IO
    - 利用IO 多路复用技术： select/epoll
    - IO读写操作还是同步
    - 单Reactor单进程： redis
        - 无法发挥多核CPU性能，如果部署多套系统，运维复杂性高
        - 业务处理过程中无法处理连接时间，容易导致性能瓶颈
    - 单Reactor多线程：
        - 业务处理放到子线程中处理
        - 多线程数据共享和访问比较复杂，需要进行同步保护
        - 单reactor主线程完成所有事件的监听和响应，容易成为性能瓶颈
        - 不使用多进程，是因为子进程和父进程数据同步比较复杂
    - 多Reactor多进程（线程）：
        - 父Reactor通过selector监控链接建立事件，建立链接后分配给子Reactor处理：
        - 子Reactor创建handler，响应其他事件
        - 优点：
            -  父进程、子进程职责明确
            -  父子进程交互简单，父进程将连接传给子进程，子进程不需要返回数据
            -  子进程间数据独立，无需同步
        -  案例： Nginx、Memcache、Netty
            -  netty 两个EventLoopGroup分别对应父进程和子进程
            -  Nginx 由子进程建立连接，通过锁一次只有一个进程accept
- Proactor
    - IO 读写操作改为异步
    - 方案
        - Proactor Initiator 创建Proactor和Handler，并注册到内核（Asynchronous Operation Processor）
        - Asynchronous Operation Processor 负责处理注册请求，并完成io操作
        - Proactor 根据时间类型回调Handler处理业务
        - Handler 完成业务处理
    - linux下AIO不完善，通过Reactor模式模拟异步模型
    - windows IOCP 实现了真正的异步IO

### 5、 高性能负载均衡
- 复杂性：增加任务分配器组件，选择任务分配算法
- 分类
    - DNS 负载均衡
        - 优点： 实现简单，成本低；就近访问
        - 缺点： 
            - 粒度太粗
            - 更新不及时
            - 扩展性差
            - 分配策略简单，负载均衡算法少；
    - HTTP-DNS 负载均衡 优缺点与DNS负载均衡相反
    - 硬件负载均衡： F5，A10
        - 优点： 功能强大、性能强大、稳定性高，支持安全防护
        - 缺点： 价格昂贵，扩展性差
        - QPS量级：100万/秒以上，200~800万/秒之间
    - 软件负载均衡： Nginx（5万/秒) ，LVS (十万级，最高到80万/秒)
        - 与硬件负载均衡的主要差别在性能和价格
        - 优点： 简单、价格便宜、灵活
        - 缺点：性能一般，功能不够硬件负载均衡强大，不具有防火墙和防DDOS攻击功能
- 负载均衡的架构
    - DNS 负载均衡用于实现地理级别的负载均衡
    - 硬件负载均衡用于集群级别的负载均衡
    - 软件负载均衡用于机器级别的负载均衡
- 算法
    - 任务平分类：将任务（加权或按比例）平分给服务器进行处理
        - 轮询： 简单
        - 加权轮询： 解决不同服务器处理能力差异的问题
        - 因不关系服务器状态，在服务器故障（负载高）时，任务分配不合理
    - 负载均衡类：按照服务器的负载（CPU、连接数、IO使用率、网卡吞吐量）进行分配
        - 站在服务端角度考虑问题，需要定时收集服务端负载数据
        - 负载最低优先：能解决任务平分类算法的缺点，但是复杂度会大幅上升
        - 算法可能会成为性能的瓶颈，或引起其他问题，使用率不高
    - 性能最优类：将任务分配给响应时间最短的服务器
        - 站在客户端角度考虑问题
        - 复杂度也很高
            - 统计每个任务的响应时间
            - 需要选择合适的采样率
            - 选择合适的采样周期
    - Hash类： 根据任务中某些关键信息进行hash运算，将相同hash的请求分配到同一台服务器
        - 源地址IP hash： 适合直接面对客户的网关层
        - ID hash：       能够缓解最终一致性过程中数据不一致的处理过程。

### 6、 高可用存储架构 - 双机架构
- 架构关键问题
    - 数据如何复制
    - 各个节点的职责是什么
    - 如何应对复制延迟
    - 如何应对复制中断
- 双机架构
    - 主备结构
        - 备机起备份作用，不参与业务读写操作
        - 备机改为主机需要人工操作
        - 优点： 简单
            - 客户端无须感应备机的存在
            - 主机和备机只进行数据复制，无须进行状态判断和主备切换
        - 缺点：
            - 备机没有提供读写操作，硬件上有浪费
            - 主机故障，不能提供读写操作
            - 故障后需要人工干预，可用性低
    - 主从结构
        - 从机提供读操作
        - 优点：
            - 主机故障，从机可以提供读操作
            - 发挥从机硬件的性能
        - 缺点：
            - 客户端需要感知主从关系，将不同操作发送到不同服务器
            - 主从复制延迟，会导致业务因数据不一致出现问题
            - 故障后需要人工干预，可用性低
            - 主机故障，不能提供写操作
    - 主备/主从自动切换结构
        - 关键点
            - 主备间状态判断
                - 状态传递的渠道
                - 状态检测的内容
            - 切换策略
                - 切换时机
                - 切换策略
                - 自动程度
            - 数据冲突解决
        - 常见架构
            - 互联式：
                - 主备机直接建立状态传递的渠道;
                - 主备共享虚拟ip，主备切换时，需要重新绑定虚拟ip
                - 客户端可以存储主备ip，在一个ip请求被拒绝时，使用另一个
                - 缺点是： 渠道故障可能导致状态误判，最终出现两个主机
            - 中介式： 
                - 主备机将状态上报给中介服务器
                - 流程： 
                    - 初始状态备机，只要和中介断开连接，自动降级成备机
                    - 中介按照策略选定主机
                    - 技术如： Zookeeper、keepalived
                - 优点： 
                    - 连接管理更简单，主备间不需要建立状态传递的渠道;
                    - 状态决策更简单，不需要考虑渠道故障
            - 模拟式：
                - 备机模拟客户端发送读写请求，根据响应情况判断主机状态
                - 优点： 简单，无需状态传输通道
                - 缺点： 有限的状态做决策，可能出现偏差
    - 主主结构
        - 优点
            - 两台都是主机，无须做状态切换
            - 客户端不需要区分角色，随便将请求发送到哪台主机都行
        - 缺点：
            - 必须保证双向复制，而很多数据时不能双向复制的，如： 库存、余额
        - 仅适用于临时性、可丢失、可覆盖的数据场景，如： session、日志数据
- 集群和分区
 

### 7、 计算高可用架构


### 8、 异地多活架构


### 9、 接口级故障处理


