### 分工解决的问题
- 如何高效地拆解任务并分配给线程

### 分工部分的模式
#### 1. Executor与线程池 
- 5种不同线程池
    - newCachedThreadPool： 
        - 无限制线程，创建新线程
        - 线程长时间空闲，会回收
        - 工作队列长度为0
    - newFixedThreadPool 
        - 固定线程数
        - 如果工作线程退出，会创建新线程
        - 无界的工作队列
    - newSingleThreadExecutor
        - 工作线程数为1
        - 无界的工作队列
    - newScheduledThreadPool
        - 与newSingleThreadExecutor类似
        - 区别是可以设置工作线程数
    - newWorkStealingPool 
        - 内部创建 ForkJoinPoint
        - 使用work stealing 算法
- ExecutorService 服务
    - Future submit(Callabletask); 
- Worker，内部静态类，基于AQS实现
- 线程池技巧
    - 避免任务堆积
    - 避免过多扩展线程
    - 警惕线程泄漏
    - 避免死锁
    - 避免使用线程池时，使用ThreadLocal
- 线程数选择
    - 目的： 
        - 降低延迟： 提升多核CPU利用率
        - 提高吞吐量
    - 优化方向： 将硬件性能发挥到极致，提升IO、CPU综合利用率
    - 探测需要使用多线程的场景：  CPU 和 I/O 设备的利用率都很低
    - 线程数计算方法
        - CPU密集型：线程数 = CPU数+1
        - IO密集型：最佳线程数 =CPU 核数 *（1 +（I/O 耗时 / CPU 耗时））
        - 等待较多：CPU核数*目标cpu利用率*（1+平均等待时间/平均工作时间）
    - 架构调整也能解决线程过多的问题
        - Reactive Stream
        
#### 2. Fork/Join
#### 3. Future
#### 4. Guarded Suspension模式
#### 5. 生产者-消费者模式
#### 6. Thread-per-Message 模式
#### 7. Worker Thread 模式
#### 8. 两阶段终止模式