#### 工作低效的原因
- 本质复杂度就是解决一个问题时，无论怎么做都必须要做的事
- 偶然复杂度是因为选用的做事方法不当，而导致要多做的事
- 工作低效是由于工作中偶然复杂度太多造成的


### 思考框架
- 三个问题
    - Where are we?（我们现在在哪？）              现状
    - Where are we going?（我们要到哪儿去？）      目标
    - How can we get there?（我们如何到达那里？）  实现路径
- 思考框架: 为什么要提出问题
    - 目标： 
        - 为什么要做这个特性
    - 目标有效性： 
        - 它会给用户带来怎样的价值？ 
        - 这个特性上线之后，怎么衡量它的有效性？
    - 实现路径： 
        - 什么样的用户会用到这个特性
        - 他们在什么场景下使用，他们又会怎样使用它？
        - 达成这个目的是否有其它手段？是不是一定要开发一个系统？
    
- 思考原则 
    - 以始为终
        - 工作的一开始就确定好自己的目标
        - 不是把别人交代给我们的工作当作目标
    - 任务分解
        - 将大目标拆分成一个一个可行的执行任务
    - 沟通反馈
        - 保证信息能够传达出去，减少因为理解偏差造成的工作疏漏
        - 保证我们能够准确接收外部信息，以免因为自我感觉良好，阻碍了进步
    - 自动化
        - 将繁琐的工作通过自动化的方式交给机器执行
 ![image](../../ref_images/20191217/ac7c923067660ebe0a1b646e616d7bf8.jpg)

### 以始为终
- 遇到事情，倒着想
- 在做事之前，先考虑结果，根据结果来确定要做的事情
- 两次创造
    - 第一次创造 --> 在头脑中的创造 
    - 第二次创造 --> 付诸实践，也就是实际的构建 
    - 第二次创造是一件成本很高的事 
- 把“终”定位成做一个对用户有价值的软件 


#### 最佳实践 --  完成的定义 
- 完成的定义： DoD（Definition of Done)
    - DoD 是一个清单，由一个个的检查项组成的，用来检查我们的工作完成情况 
    - DoD 的检查项应该是实际可检查的
    - DoD 是团队成员间彼此汇报的一种机制 
- 特性开发完成 
    - 开发人员经过了需求澄清、功能设计、编写代码、单元测试 
    - 通过了测试人员的验收，确保代码处于一个可部署的状态 
    - 相关文档已经编写完毕
- 开发完成
    - 开发人员经过了需求澄清、功能设计、编写代码、单元测试 
- https://github.com/dreamhead/moco
- 程序员的交付物并不应该是代码，而是一个可工作的软件 

#### 需求的问题-确定的需求
- 在做任何需求或任务之前，先定好验收标准
- 功能列表的问题
    - 只是一些简单的描述，你并不能看到全局
    - 将一个完整的需求敲成了碎片
    - 补充验收标准也会极大程度地改善双方协作的效率
- 新的需求描述方式： 用户故事（User Story）
    - 关注用户在系统中完成一个动作需要经过怎样的路径
    - 格式： 
        - 标题
        - 概述： 作为一个什么角色，要做什么样的事，以便达成一种怎样的效果
        - 详述： 详细地描述这个用户故事的完整流程
            - 操作流程
            - 用户界面
        - 验收标准（清晰地定义出需求边界）
            - 正常使用流程
            - 异常使用流程
            - BDD（Behavior-Driven Development 行为驱动开发）
            - 业务上的实现细节

#### 需求的问题-不确定的需求
- 默认所有需求都不做，直到弄清楚为什么要做这件事
- 独立思考，多问几个为什么，尽可能减少掉到“坑”里之后再求救的次数
- 软件开发的主流由面向确定性问题，逐渐变成了面向不确定性问题
- 精益创业
    - 解决的是面向不确定性创造新事物
    - 可能少浪费的前提下，面向不确定性创造新事物 
    - 唯一能做的事情就是“试” 
    - 反馈循环 “开发（build）- 测量（measure）- 认知（learn）
    - 好想法继续加强，不靠谱的想法丢掉算了
    - 重要概念： 经过验证的认知
    ![image](../../ref_images/20191217/c398ebcf72a56f11c6257bc67211310b.jpg)
    - 最好的办法就是以最低的成本试 MVP（Minimum Viable Product） 
- 问题：
    - 做这个产品特性，你要验证的东西是什么呢
    - 验证的目标是否有数据可以度量
    - 解决问题的重要程度： 是否有更重要的问题需要解决
    - 验证这个目标是否有更简单的解决方案


#### 跳出程序员的角色看问题
- “独善其身”不是好事  
- 不同角色工作上真正的差异是上下文的不同 
- 花大力气去解决一个可能并不是问题的问题，常常是很多程序员的盲区
- 跳出程序员角色思维，扩大自己工作的上下文 
- 单一维度的思考，在多维度思考者的眼里几乎就是漏洞百出的 


#### 做事之前先进行推演
- 结果是重要的，然而通向结果的路径才是更重要的 
- 多数情况下，即便目标清晰，路径却是模糊的 
- 沙盘推演 
- 在动手做一件事之前，先推演一番

#### 用数字衡量
- 问一下自己，我的工作是不是可以用数字衡量
- 所谓的直觉，通常是一种洞见（Insight）
- 洞见很大程度上依赖于在领域长期的沉淀和积累，这其实是大数据
- 当事情复杂到一定程度时，简单地靠感觉是很难让人相信的
- 使用数字衡量结果的例子
    - 基于数字进行技术决策
    - 从数字中发现问题  AIOps 


#### 迭代0 的事务清单
1. 需求方面
    - 细化过的迭代 1 需求
        - 待开发需求列表
        - 根据优先级挑选出迭代1需要开发的功能
        - 需求细化到可执行的程度 
    - 用户界面和用户交互 
        - 用户交互是需求的一部分
2. 技术方面
    - 基本技术准备： 技术选型、技术架构、数据库表设计、持续集成、测试
        - 把测试当作规范确定下来的办法就是把测试覆盖率加入构建脚本
    - 发布准备： 
        - 数据库迁移： 工具flyway
        - 发布
![image](../../ref_images/20191217/b9fd38bcb05c2e918d231154a0af1655.jpg)

#### 以终为始总结
- 最佳实践
    - DoD，确定好完成的定义，减少团队内部的理解不一致。
    - 用户故事，细化出有价值的需求
    - 持续集成，通过尽早集成，减少改动量，降低集成的难度
    - 精益创业，减少过度开发不确定性产品带来的浪费
    - 迭代 0，在项目开始之前，做好一些基础准备
- 思维转变
    - 两次创造: 
        - 是在头脑中的创造 
        - 付诸实践,实际的构建
    - 在更大的上下文内发现自己的“终”
    - 通过推演，找到通往“终”的路径。
    - 用可度量的“数字”定义自己的“终”
- 实战指南
    - 遇到事情，倒着想
    - 在做任何事之前，先定义完成的标准
    - 在做任何需求或任务之前，先定好验收标准
    - 尽早提交代码去集成
    - 默认所有需求都不做，直到弄清楚为什么要做这件事
    - 扩大自己工作的上下文，别把自己局限在一个“程序员”的角色上
    - 在动手做一件事之前，先推演一番。
    - 问一下自己，我的工作是不是可以用数字衡量。
    - 设计你的迭代 0 清单，给自己的项目做体检。

### 任务拆解
- 一个大问题，我们都很难给出答案，但回答小问题却是我们擅长的
- 难点   给出一个可执行的分解
- 任务分解是一个知难行易的过程  知道怎么分解是困难的 
- 可执行定义： 是否能清楚地知道这个问题该如何解决
- 任务分解是拥抱变化的前提
- 小事反馈周期短，而大事反馈周期长
- 将任务拆小，越小越好 
- 按照完整实现一个需求的顺序去安排分解出来的任务。


#### 测试
- 精益原则的重要思想：内建质量（Build Quality In）
- 冰淇淋蛋卷测试模型
![image](../../ref_images/20191217/d869ad1b05c1dc626a928ca63ed2c6a1.jpg)
- 行业的最佳实践--测试金字塔
![image](../../ref_images/20191217/5d0b1895d6b9c61ea875d2a8e951a979.jpg)
- 越是底层的测试，牵扯到相关内容越少，而高层测试则涉及面更广。
- 从代码是否可测的角度分析 
    - 尽量不写 static 方法 
    - 写代码之前，请先想想怎么测。 
- 测试的坏味道
    - 测试不够简单              简单到一目了然，不需要证明它的正确性
    - 在一个测试里做很多的事情  多写几个测试，每个测试覆盖一种场景
    - 测试没有断言
- 测试的基本结构： 前置准备、执行、断言和清理 
- 好的测试
    - Automatic，自动化
    - Thorough，全面的
    - Repeatable，可重复的
    - Independent，独立的
    - Professional，专业的
 
#### 需求的分解 
- 主题（epic）不能砍的需求
    - 在敏捷开发中，有人称之为主用户故事（master story） 
- 需求分解的原则 粒度越小越好
- 评价用户故事的原则 INVEST 
    - Independent，独立的
    - Negotiable，可协商的
    - Valuable，有价值的
    - Estimatable，可估算的
    - Small，小 
    - Testable，可测试的 
- 用户故事，之所以是故事，就是要讲，要沟通
- 估算的过程也是大家加深对需求理解的过程 
- 想要管理好需求，先把需求拆小

### 需求管理法
- 就凭一句“老板说的”，我们就可以判断出，产品经理缺乏对需求管理应有的理解
- 需求的优先级
    - 优先级这种事大家也是可以谈的
    - 区分优先级的原因： 时间是有限的，有限的时间内你能完成工作的上限是一定的
    - 优先级是一个时间管理的问题
    - 艾森豪威尔矩阵，需求分成四个部分：重要且紧急，重要不紧急，不重要且紧急，不重要不紧急
        - 重要且紧急的事情要立即做
        - 重要但不紧急的事情应该是我们重点投入精力的地方
        - 紧急但不重要的事情，可以委托别人做。
        - 不重要不紧急的事情，尽量少做
        - 如果不把精力放在重要的事情上，到最后可能都变成紧急的事情
    - 默认所有需求都不做，直到弄清楚为什么要做这件事         
    - 当有多个需求来源时，我们该如何确认哪个需求是最重要的呢
        - 跳出这个上下文，到更大的上下文中
        - 你判断不了哪个需求更重要，就请更高一级的老板来判断
        - 当员工想不明白的事，换成老板的视角就全明白了
        - 为人做事同样要不断扩展自己的上下文，这也就是我们常说的涨见识
- 尽量做最重要的事        
        
### 最小可行产品（Minimum Viable Product，MVP）
- MVP : “刚刚好”满足客户需求的产品
    - 关键在于理解“最小”和“可行
    - “最小”，指的是最小的代价,就是能不做的事情就不做，能简化的事情就简化
        - 要做的是验证一个想法的可行性，甚至不是为了开发一个软件，开发软件只是一种验证手段
            - 产品文档
            - 原型工具    
        - 误区，容易把解决方案当做问题 
    - 可行的路径
        - 转换一下思路，不是一个模块做得有多完整，而一条用户路径是否通畅
        - 当时间有限时，我们需要学会找到一条可行的路径，在完整用户体验和完整系统之间，找到一个平衡           
- 在探索产品的不确定性上的最佳实践是精益创业
- 想要在实践中运用好最小可行产品的理念，就是要用最小的代价找到一条可行的路径
- 写代码通常是代价非常高的解决方案，它应该成为最后的产品解决方案

### 沟通反馈
- 人生如此不如意，真实的原因往往是因为你想得太美好
- 沟通反馈，就是我们与真实世界互动的最好方式
- 香农信息论中的一个通信模型
    - 信源（Information Source），它负责产生信息（Message）
    - 发送器（Transmitter），它会对信息进行某些操作，也就是对信息编码，产生信号（Signal）
    - 信道（Channel），它是信号传送的媒介
    - 接收器（Receiver），它是对信号执行发送器的逆操作，解码信号，提取出信息
    - 信宿（Destination），它负责接收信息
    - 噪声（Noise），指的是削弱信号的东西
- 理解偏差是怎么产生的    
    - 一方面，有些人表达不清楚，
    - 另一方面，因为自己没有相关背景，依然无法得知人家表达的信息
    - 再有编码和解码不是一个版本的时候
    - 每个人经历见识的差异，造成了各自编解码器的差异
- 解决方法： 改善编解码
    - 很多程序员讲东西的通病：讲东西直奔细节
    - 接纳真实世界的反馈
        - 一是需要我们打开自己的接收器，把信号接纳进来，让反馈进来，这是解码的前提；
        - 二是扩展见识，提升自己解码器的效果，更好地理解别人要表达的内容到底是什么
- 编写可维护的代码
    - 计算机科学中只有两大难题：缓存失效和命名
    - 命名难题
        - 代码规范给出的要求，大多是格式上的要求，只是底线
        - 名字起得是否够好，一个简单的评判标准是，拿着代码给人讲，你需要额外解释多少东西
    - 代码为谁而写 ？ 
        - 写代码的目的是与人沟通
        - 人要负责将业务问题和机器执行连接起来，缺少了业务背景是不可能写出好代码的
    - 用业务语言编程    
        - 订单 拆分成交易订单、物流订单和支付订单
        - 为了不让自己“分裂”，最好的办法就是把这些概念在代码中体现出来
        - 把不同的概念分解出来，这其实是限界上下文（Bounded Context）的作用
        - 在代码里尽可能使用业务语言，这是通用语言（Ubiquitous Language）的作用
- 轻量级沟通
    - 开会是为了解决问题，但真实情况却是开了会又没有解决多少问题
    - 凡是效果特别好的会议，基本上都是用来做信息同步的
    - 那效果不好的会议，几乎都是那些讨论会
    - 开会是一种重量级的沟通，几乎是我们日常工作中最重的。它有很强的仪式感
    - 改善会议的第一个行动项是，减少参与讨论的人数
    - 第二个行动项是，如果你要讨论，找人面对面沟通
    - 站会（Standup） 建议你只说三件事
        - 我昨天做了什么？ 为了与其他人同步进展，看事情是否在计划上
        - 我今天打算做什么？ 同步你接下来的工作安排
        - 我在过程中遇到了什么问题，需要请求帮助 与其他人的协作
            - 在站会上，你只要在问题和求助中告诉大家，你有一个问题，需要相关人讨论，结束
    - 多面对面沟通，少开会
- 可视化的优势
    - 就人脑的进化而言，处理图像的速度远远快于处理文字
    - 看板：将我们正在进行的工作变得可视化
        - 看板可以帮助你一眼看出许多问题
        - 我们应该限制 WIP（Work-In-Progress），因为一个人多线程工作，效果不会好
    - 多尝试用可视化的方式进行沟通
- 









































- https://martinfowler.com/articles/feature-toggles.html
- https://www.infoq.cn/article/function-switch-realize-better-continuous-implementations