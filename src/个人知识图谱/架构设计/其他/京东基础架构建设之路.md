- 容器
    - 容器的本质是经过隔离与限制的linux进程
    - 容器之间共享物理机的iinux内核
    - 容器之间的隔离性依赖于linux提供的namespace
    - 容器对资源的限制是通过linux提供的cgroup来实现的
    - 镜像和根目录只保留制度和少量读/写的文件，频繁读写或大量写的文件，尽量使用外挂的volumn
- 数据库
    - 开发bin log 管理服务，统一管理数据变动消息/监听
    - 弹性数据库
        - 使用mysql_use_result 分批读取数据，在代理层完成数据合并、分页功能
        - 排序功能下推到mysql，转换成k路归并问题
- 分布式存储
    - 1主+2从，全部写入成功后才将成功返回给客户，优先从从机读取数据
    - 存储引擎采用append-only模式
    - 小文件存储
        - 为上传的每个小文件生成唯一key： groupId+chunkId+offset+length+checksum+signature
        - 只保存原图，CDN未命中回源时，实时处理并返回，满足业务的多变性
        - 引入ICC、IPP编译将图片缩放性能提升到原有的3倍以上
    - 大文件存储
        - 采用链式复制
        - 将一个大文件拆分成多个块
    - 对象存储
        - 本身没有目录概念
        - 元数据支持按前缀进行list操作，即按照目录层次查询
    - 缓存平台
        - 能够自动进行故障恢复、在线扩容、负载均衡，且用户无感知
        - 核心问题
            - 精确的故障监测
                - 避免网络不同时误判的问题： 
                    - 部署多个探测实例到多个机架
                    - 只要有一个探测实例探测到服务存活，服务就是存活的
                    - 如果没有实例反馈服务存活，且超过半数实例反馈服务死亡时，判定服务死亡
            - 自动故障切换
            - 在线无损扩容
                - 一致性哈希协议
                - 扩容过程中采用代理的方式
                - 服务端引入slot概念，数据按照slot组织
                - 迁移过程中，服务端以slot未单位进行数据迁移
            - 关键的监控和报警服务
                - 对集群的各项指标进行监控，入：OPS、内存使用率、网络流量
                - 当一段时间内，资源使用达到设置的阈值，会自动启动扩容/缩容操作
                - 控制在同一台物理机中最大可部署实例数量，同一个分片的主从实例需要跨机架
                - 大key扫描
                    - Redis单线程，不适合一次处理大量数据
                    - 定期扫描值比较大的key、大集合的key
                    - 定期扫描slow log
        - 可以通过增加多从的方式扩展单个分片的读能力
        - 常见问题
            - 单次取出集合中全部数据： 集合数据多会造成服务卡死
            - 单个Value过大
            - 单key写入频次过高： 拆分成多key写，读取的时候再做合计计算
            - 热key本地没有做缓存
    - 大表存储
        - 支持key检索、支持范围扫描、支持款表
        