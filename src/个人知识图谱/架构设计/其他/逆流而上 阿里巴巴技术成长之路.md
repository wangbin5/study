- 预防缓存被击穿总结
    - 评估缓存是否满足具体业务场景的请求流量，不是简单的对预估访问流量除以单台缓存的最大服务能力  
        - 单机中 SUM(key访问频次*key对应值大小) < 单机的最大网络流量
        - 单机中 SUM(key访问频次) < 单机的最大请求量
    - 考虑当前业务场景中被高并发访问的key
    - 考虑key对应的value的大小
    - 还要做好缓存元素key的访问监控
- MySql 线程池及可能引发的问题
    - 5.6 版本新增功能
    - 用较少的线程支持更多的数据库连接和网络并发
    - 对线程资源进行分组，线程只有少量（2~3）个线程
    - 如果一组中都在执行长时间访问的连接（如：binlog dump任务）任务，会导致后续命令长期等待直到超时
    - 属于线程池均衡问题，MySql线程池分组功能实际上拆分了资源池
- Mysql 优化参数
    - innodb_buffer_pool_size: innodb引擎缓冲池大小，建议配置主机内存70%~80%之间
    - temp_table_size: 优化查询语句的时候，避免使用临时表
    - 公式： T = S/V
        - T SQL语句执行时间
        - S SQL所需的资源总量
        - V SQL语句单位时间所能放完的资源量
    - 优化思路
        - S不变，提升V测策略
            - 使用索引，将随机IO转换为速度较快的顺序IO
            - 提升内存，加载数据到内存中，比磁盘速度明显提升
            - 使用SSD替换机械硬盘
            - 使用较高配置的硬件完成速度的提升
        - V不变，减少S的策略
            - 使用适当索引，避免全表扫描
            - 站在业务的角度上，优化SQL（SQL逻辑有变化，业务上等价）
- 分布式系统锁+重试对幂等控制的影响
    - 分布式锁打穿并发控制的情况
        - 上层业务系统层面有重试机制
        - 业务请求存在一定时间后提交成功的情况，并且分布式锁持有时间小于最大执行时间
        - 下游系统缺乏其他有效幂等控制的手段
    - 解决方案
        - 调整超时时间，事务执行时间+重试等待时间 < 分布式锁时间
        - 最好在数据库层面做幂等控制，比如： 唯一键值
    - 幂等控制是资金安全的重要控制手段
- 使用事务消息解决红包发放中的分布式事务问题
    - 可以解决的原因
        - 扣款决定了红包能否正确发放，增加红包的操作可以通过重试保证一定能成功
        - 允许中间状态
    - 好的技术方案都是对业务场景的深刻理解和权衡之后获得的
    - 通用技术方案并不是唯一的好的选择
- 分布式系统中部分失败的处理方法
    - Convert Partial Failure to Fail-Stop Failure
    - 一致性协议是基于crash failure（Fail-Stop） 设计的，部分失败可能不会触发故障机下线，重新选主
    - 架构性缺陷：心跳服务与业务服务脱节
- java序列化问题
    - 模型定义中同时提供了get/is 方法 --> 代码不规范
    - 序列化框架使用Class.getMethods 方法存取数据
        - jvm中不保证getMethods方法返回的顺序一致
    - 更好的设计： 增加隔离层，在业务系统中使用适配器模式，重新定义一个类来做系统见的对接
- JVM 触发JIT编译导致CPU负载高的问题
    - 使用JDK 8 中提供的hotcache 来解决