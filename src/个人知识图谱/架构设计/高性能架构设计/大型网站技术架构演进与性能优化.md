### 总体设计要求
- 要保证数据的一致性，一般都需要对最细粒度的数据做单写控制
- 数据层需要屏蔽应用层代码对数据分布的感知，是对数据的分区或者分片不会影响应用代码的编写
- 分布式消息框架需要保证：1) 最终一致性　2) 消息的有序性
- 延时消息：核心是需要一个延时事件的触发器
- 同机房场景下，数据库主从复制的延迟非常低，对应用层没有什么影响。
- 分层设计中，避免使用超级数据结构（比如一个对象，传递到多层，每层都可能修改），参数类型最好采用原生数据类型
- 分布式集群设计思路：1) master/slave 模式 2) 无主对等设计
- 配置中心采用拉模式，是从Client数量和DataNode发生故障的概率之间，选择了支持更多的client数量。
- 分布式改造解决的核心问题
    - 分层拆分，例如：前后端分离
    - 横向不同业务系统拆分，业务拆分会引起组织结构的变化
    - 解决系统之间的连接问题

### 无线化演进
- 无线链路优化
    - 服务端响应时间只占整个请求路径上的一小部分
        - PC端更重要的是优化首屏的加载
        - 无线端则更多的是优化中间的管道
    - 常用优化方法
        - 做请求合并（减少网络请求次数）的收益是比较大的
        - 数据大小对性能的影响比PC端更明显，控制页面大小对无线端性能影响很大
        - CDN 直接Cache 可以大幅度提升性能
        - 小数据情况下，动态加速和直接回主站没有明显优势，待动态加速成熟后再走CDN
        - WebP图片优化（m3级别）能大幅提升性能

### 电商业务中台
- 一套有业务能力标准、运行机制、业务分析方法论，配置管理和执行系统以及运营团队构成的体系
- 能够给各业务方提供快速、低成本创新的能力。
- 中台的建模是针对特定场景的，超出这种场景的使用仍然会受限


### 全球化部署方案（单元化）
- 按照某种维度对数据进行水平拆分，拆分后数据位于不同地域且对数据的更新时单写的。
- 业务单元内闭环： 单元内的业务操作尽量做到自我封闭，单元内包含业务所需的所有服务和所依赖的数据
- 单元化部署： 单元作为服务扩容部署的基本单位
- 受到的约束
    - 数据正确性：1) 数据不会错　2) 数据不会丢
    - 单元封闭: 减少跨单元访问，尽量做到业务透明
    - 就近访问：提供实时性、高性能
- 单元化解决的问题
    - 解决物理资源限制的问题
    - 解决高可用（异地多活）问题
    - 解决国际化、全球化业务问题
- 数据单元化的划分方式
    - 中心-多单元模式
        - 把最小的核心系统单元化就能达成目标
        - 大部分业务系统可以放到中心单元
        - 数据层面，中心保留全量数据，单元机房可以根据需要决定是否需要存储部分业务的全量数据
    - 多机房A-A模式
        - 业务层面Active-Active模式
        - 数据库即便A-A，表行级别数据 A-S（主备） 模式
        - 保证同一数据的更新始终发生在同一个机房
    - 数据划分维度
        - 买家维度： 
            - 优点： 高频操作，优先选择
            - 缺点： 1）商品需要全量复制 2）库存不好处理
        - 卖家维度
            - 优点: 卖家体验好，适合本地化服务的卖家，如： 滴滴
            - 缺点：买家操作可能需要跨区域，性能差，用户体验差
    - 数据划分维度选择的原则
        - 就近访问：用户体验好
        - Hash取模：没有考虑用户的地域因素，跨地域访问性能差
        - 对用户建立路由表：1）灵活且功能强大 2）路由表大，容易成为中心节点 3）稳定性和性能瓶颈存在隐患
    - 数据路由方案
        - 主键ID做标识： 前4位表示国家
            - 适用范围窄
            - 系统从新建的时候做规划
            - 可以和路由表一起使用，作为默认路由方案，减少路由表大小
        - 设置路由表： 保存 <用户id,地域ID>的映射关系
            - 限制
                - 访问量会很大：路由表存放的信息要在内存里，否则会出现性能瓶颈
                - 存在单点问题： 路由表需要集中控制，一旦路由表错误数据会错乱
                - 路由表数量有限，不能太大，否则内存是个负担
            - 结合主键ID做标识方案，减少路由表大小
        - trace 透传
            - 网关从路由表查询地域id，透传到Http、RPC、及数据层中间件
            - 问题： 1）最怕有些地方丢掉trace 2）trace的透传依赖中间件的配合
        - 路由模式
            - 中心模式：没有单元化的服务都会中心单员
            - 单元模式：单元化部署的服务，需要被路由到正确的单元完成
            - 混合模式：路由规则是本单元优化，本单元不存在回中心单元调用
                - 读写分离： 读操作可以在本单元/中心单元完成，写操作必须被中心单元完成
        - 路由切换步骤： 
            - 首先服务层、消息层、数据层要禁写
            - 消息层推送新的路由规则
            - 再推送数据层、服务层以及接入层的新的路由规则
            - 恢复禁写
        - 各层级路由的注意事项
            - 接入层路由： 1）多域名跳转 2）基于CDN代理 3） ng 存储路由表
            - 服务层路由
            - 数据层路由： 1） 要做正确性校验 2）支持区域间的数据复制 3）Cache数据也要一致性
    - sequence ID 冲突问题的解决思路
        - 全局统一的Sequence生成器
        - 提前预设分段
        - 设置起始值加步长的方式，数据表做更新
- 全球化遇到的坑
    - 脏数据： 单元内写了不应该在本单元写的数据引起的
    - 路由规则不一致： ng、服务框架、消息框架、DbProxy中路由规则不一致，导致脏数据
    - 路由规则生效延迟
    - 服务接口改造遗漏
    - 应用层绕过路有规则直接写数据库
    - MYSql同步数据错误
    - 数据同步故障
    - 中心-单元网络错误


### 应用程序性能优化
- 代码级优化：提升系统单机QPS,减少RT提升用户体验
- 优化思路：首先知道系统的瓶颈在哪里，最短的木板决定木桶的容量
    - 压测工具+代码热点分析工具（JProfiler和Yourkit）
    - 全链路压测技术+影子表
- CPU没有压满，QPS就上不去了的问题排查思路
    - 使用Jstack，查看当前java线程在做什么： 是否等待远程调用返回、等待锁
    - 如果压测请求不在本机，查询当前请求的TCP连接数
    - 检查网卡是否达到瓶颈
    - IO也可能成为瓶颈
- 影响性能的关键因素
    - QPS与线程关系： 
        - 减少CPU的执行时间对QPS有实质性的提升，
        - 减少线程的等待时间对QPS的提升不明显
        - 在高IO系统中，QPS与RT的关系不是线性的
    - 设置最佳线程数
        - 单用户压测 --> CPU 消耗百分比达到目标
        - 慢慢增加并发请求进行性能压测
    - 最佳内存设置
        - 判断是否达到内存瓶颈： 观察Old区内存增长速度是否正常
        - Eden区太小，导致minor GC频繁
        - survivor区太小，导致对象容易被直接拷贝到老年区
        - Yong区太大，容易导致一次minorGC 耗时过长
        - 建议配置：Yong区占堆内总内存的1/4,Survivor区占Yong区的1/8
        - 单个请求占用内存大小： Eden/(QPS*minorGc 平均间隔时间)
- java特性优化：减少字符编码（字符、字节互相转换）

### 秒杀系统优化
- 2013年下单减库存TPS 最高达到1秒1500个请求
- 优化原则
    - 隔离热点数据，禁止1%请求影响剩余99%请求
        - 业务隔离： 秒杀系统单独报名
        - 系统隔离： 分组部署方式，秒杀请求落入单独集群
        - 数据隔离： 启用单独的cache集群和mysql数据库处理热点数据
    - 动静分离： 静态数据CDN处理，动态数据数量少，有服务端处理
    - 基于时间分片削峰，增加秒杀答题模块
        - 防止秒杀器
        - 拉长了峰值下单请求的时间
    - 数据分层校验
        - 读数据不做一致性校验，允许漏过不符合规则的写请求
        - 对写请求做限流保护
        - 对写数据做强一致性校验
    - 大并发读请求
        - 增加本地缓存，允许数据不一致
    - 大并发写请求： 
        - 单行热点数据更新存在并发锁的问题
        - 采用应用层排队： 需要将热点数据路由到单台服务器处理
        - 采用数据库层排队： 修改数据库源码，难度大 
- 支撑应用运行的基础环境，有更大的优化空间


### 系统稳定性建设
- 架构阶段注意点
    - 避免单点
        - 统一登录、网关、安全过滤服务，按照人群划分，不要在逻辑上出现单点
        - 尽量把服务拆分成组件迁移到不同端上执行，比如： 将安全服务作为模块运行在nginx或应用及其中，而不是独立服务
    - 分组隔离
    - 异步化：系统间通讯尽量采用异步方式
    - 异地容灾
- 编码阶段注意点
    - 错误捕获：防御性编程可以更好的保证系统的健壮性
    - 异步线程
    - 超时处理
    - 限流保护
- 发布阶段注意点
    - 分批发布
    - 多版本发布
- 运行阶段注意点
    - 实时监控报警
    - 过载保护
    - 自动降级
    - 实时数据对账
    - 核心原则：　实时发现问题，提供必要保护措施
- 故障发生时处理方法
    - 快速止损
    - 定位故障
    - 快速回复
- 高可用体系：　
    - 压测体系
        - 单系统压测
        - 全链路压测
            - 流量标记的传递问题
            - 影子表
    - 管控体系
        - 开关系统
        - 预案系统
        - 限流降级系统
    - 监控体系
    - 恢复体系
    - 度量体系